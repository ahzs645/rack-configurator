import type { RackConfig, PlacedDevice } from '../state/types';
import { getDevice } from '../data/devices';
import JSZip from 'jszip';

/**
 * Generate OpenSCAD code from a rack configuration
 */
export function generateScadCode(config: RackConfig, useConfigPreview = true): string {
  const lines: string[] = [];

  // Header with timestamp
  lines.push('/*');
  lines.push(' * Rack Configuration');
  lines.push(` * Generated by Rack Configurator on ${new Date().toISOString()}`);
  lines.push(' *');
  lines.push(` * Rack: ${config.rackU}U, ${config.earStyle} ears, ${config.backStyle} back`);
  if (config.isSplit) {
    lines.push(` * Split at: ${config.splitPosition || 'auto'}mm`);
    lines.push(` * Left devices: ${config.leftDevices.length}`);
    lines.push(` * Right devices: ${config.rightDevices.length}`);
  } else {
    lines.push(` * Devices: ${config.devices.length}`);
  }
  lines.push(' */');
  lines.push('');

  // Includes
  lines.push('use <components/rack_generator.scad>');
  lines.push('include <components/devices.scad>');
  lines.push('include <components/constants.scad>');
  lines.push('');

  // Quality setting
  lines.push('$fn = 32;');
  lines.push('');

  // Determine preview settings
  const showPreview = useConfigPreview ? config.showPreview : false;
  const showLabels = useConfigPreview ? config.showLabels : false;

  if (config.isSplit) {
    // Split panel mode
    const leftDevicesCode = generateDevicesArray(config.leftDevices);
    const rightDevicesCode = generateDevicesArray(config.rightDevices);

    lines.push('// Split rack faceplate');
    lines.push('rack_faceplate_split(');
    lines.push(`    rack_u = ${config.rackU},`);
    lines.push(`    panel_width = ${config.panelWidth || 450.85},`);
    lines.push(`    left_devices = ${leftDevicesCode},`);
    lines.push(`    right_devices = ${rightDevicesCode},`);
    lines.push(`    split_x = ${config.splitPosition},`);
    lines.push(`    plate_thick = ${config.plateThickness},`);
    lines.push(`    corner_radius = ${config.cornerRadius},`);
    lines.push(`    ear_style = "${config.earStyle}",`);
    lines.push(`    ear_thickness = ${config.earThickness},`);
    lines.push(`    ear_position = "${config.earPosition}",`);
    lines.push(`    hook_pattern = ${JSON.stringify(config.toollessHookPattern || [true])},`);
    lines.push(`    trim_pattern = ${JSON.stringify(config.toollessHookTrimPattern || [])},`);
    lines.push(`    clearance = ${config.clearance},`);
    lines.push(`    hex_diameter = ${config.hexDiameter},`);
    lines.push(`    hex_wall = ${config.hexWall},`);
    lines.push(`    back_style = "${config.backStyle}",`);
    lines.push(`    cutout_edge = ${config.cutoutEdge},`);
    lines.push(`    cutout_radius = ${config.cutoutRadius},`);
    lines.push(`    show_preview = ${showPreview},`);
    lines.push(`    show_labels = ${showLabels},`);
    lines.push(`    render_part = "${config.renderMode}",`);
    lines.push(`    joiner_type = "${config.joinerType || 'screw'}",`);
    lines.push(`    joiner_nut_side = "${config.joinerNutSide || 'right'}",`);
    lines.push(`    joiner_nut_depth = ${config.joinerNutDepth || 4.5},`);
    lines.push(`    joiner_screw_type = "${config.joinerScrewType || 'M5'}",`);
    lines.push(`    joiner_nut_floor = ${config.joinerNutFloor ?? 0}`);
    lines.push(');');
  } else {
    // Single piece mode
    const devicesCode = generateDevicesArray(config.devices);

    lines.push('// Single piece rack faceplate');
    lines.push('rack_faceplate(');
    lines.push(`    rack_u = ${config.rackU},`);
    lines.push(`    panel_width = ${config.panelWidth || 450.85},`);
    lines.push(`    devices = ${devicesCode},`);
    lines.push(`    plate_thick = ${config.plateThickness},`);
    lines.push(`    corner_radius = ${config.cornerRadius},`);
    lines.push(`    ear_style = "${config.earStyle}",`);
    lines.push(`    ear_thickness = ${config.earThickness},`);
    lines.push(`    ear_position = "${config.earPosition}",`);
    lines.push(`    hook_pattern = ${JSON.stringify(config.toollessHookPattern || [true])},`);
    lines.push(`    trim_pattern = ${JSON.stringify(config.toollessHookTrimPattern || [])},`);
    lines.push(`    clearance = ${config.clearance},`);
    lines.push(`    hex_diameter = ${config.hexDiameter},`);
    lines.push(`    hex_wall = ${config.hexWall},`);
    lines.push(`    back_style = "${config.backStyle}",`);
    lines.push(`    cutout_edge = ${config.cutoutEdge},`);
    lines.push(`    cutout_radius = ${config.cutoutRadius},`);
    lines.push(`    heavy_device = ${config.heavyDevice},`);
    lines.push(`    show_preview = ${showPreview},`);
    lines.push(`    show_labels = ${showLabels}`);
    lines.push(');');
  }

  return lines.join('\n');
}

/**
 * Generate the devices array in OpenSCAD syntax
 * Device format: ["device_id", offsetX, offsetY, mountType, backStyle]
 * Device with patch panel: ["device_id", offsetX, offsetY, mountType, backStyle, patchPanelPorts]
 * Device with shelf: ["device_id", offsetX, offsetY, "shelf", backStyle, [shelfParams]]
 * Custom device format: ["custom", offsetX, offsetY, mountType, [w, h, d], "name", backStyle]
 * Custom device with patch panel: ["custom", offsetX, offsetY, mountType, [w, h, d], "name", backStyle, patchPanelPorts]
 * Custom device with shelf: ["custom", offsetX, offsetY, "shelf", [w, h, d], "name", backStyle, [shelfParams]]
 * backStyle can be "default" to use global setting, or "solid"/"vent"/"none" for override
 * shelfParams = [useHoneycomb, notch, notchWidth, screwHoles, cableHolesLeft, cableHolesRight]
 */
function generateDevicesArray(devices: PlacedDevice[]): string {
  if (devices.length === 0) {
    return '[]';
  }

  const deviceStrings = devices.map((device) => {
    // Use "default" if no per-device backStyle is set, otherwise use the specific style
    const backStyle = device.backStyle || 'default';
    const patchPanelPorts = device.patchPanelPorts || 6;  // Default to 6 ports

    // Generate shelf params array if this is a shelf mount
    const shelfParams = device.mountType === 'shelf' ? generateShelfParams(device) : null;

    if (device.deviceId === 'custom') {
      // Custom device: ["custom", offsetX, offsetY, mountType, [w, h, d], "name", backStyle, extraParams?]
      if (device.mountType === 'patch_panel') {
        return `        ["custom", ${device.offsetX}, ${device.offsetY}, "${device.mountType}", [${device.customWidth}, ${device.customHeight}, ${device.customDepth}], "${device.customName || 'Custom Device'}", "${backStyle}", ${patchPanelPorts}]`;
      }
      if (device.mountType === 'shelf' && shelfParams) {
        return `        ["custom", ${device.offsetX}, ${device.offsetY}, "${device.mountType}", [${device.customWidth}, ${device.customHeight}, ${device.customDepth}], "${device.customName || 'Custom Device'}", "${backStyle}", ${shelfParams}]`;
      }
      return `        ["custom", ${device.offsetX}, ${device.offsetY}, "${device.mountType}", [${device.customWidth}, ${device.customHeight}, ${device.customDepth}], "${device.customName || 'Custom Device'}", "${backStyle}"]`;
    } else {
      // Standard device: ["device_id", offsetX, offsetY, mountType, backStyle, extraParams?]
      if (device.mountType === 'patch_panel') {
        return `        ["${device.deviceId}", ${device.offsetX}, ${device.offsetY}, "${device.mountType}", "${backStyle}", ${patchPanelPorts}]`;
      }
      if (device.mountType === 'shelf' && shelfParams) {
        return `        ["${device.deviceId}", ${device.offsetX}, ${device.offsetY}, "${device.mountType}", "${backStyle}", ${shelfParams}]`;
      }
      return `        ["${device.deviceId}", ${device.offsetX}, ${device.offsetY}, "${device.mountType}", "${backStyle}"]`;
    }
  });

  return '[\n' + deviceStrings.join(',\n') + '\n    ]';
}

/**
 * Generate shelf parameters array for OpenSCAD
 * Returns: [useHoneycomb, notch, notchWidth, screwHoles, cableHolesLeft, cableHolesRight]
 */
function generateShelfParams(device: PlacedDevice): string {
  const useHoneycomb = device.shelfUseHoneycomb !== false;  // Default true
  const notch = device.shelfNotch || 'none';
  const notchWidth = device.shelfNotchWidth || 100;
  const screwHoles = device.shelfScrewHoles || 0;
  const cableHolesLeft = device.shelfCableHolesLeft || 0;
  const cableHolesRight = device.shelfCableHolesRight || 0;

  return `[${useHoneycomb}, "${notch}", ${notchWidth}, ${screwHoles}, ${cableHolesLeft}, ${cableHolesRight}]`;
}

/**
 * Get the effective dimensions of a placed device
 */
export function getPlacedDeviceDimensions(device: PlacedDevice): {
  width: number;
  height: number;
  depth: number;
  name: string;
} {
  if (device.deviceId === 'custom') {
    return {
      width: device.customWidth || 50,
      height: device.customHeight || 30,
      depth: device.customDepth || 50,
      name: device.customName || 'Custom Device',
    };
  }

  const deviceData = getDevice(device.deviceId);
  if (deviceData) {
    // Special handling for patch panel - calculate width based on port count
    if (device.mountType === 'patch_panel') {
      const ports = device.patchPanelPorts || 6;
      const keystoneSpacing = 19; // mm per keystone slot
      return {
        width: ports * keystoneSpacing,
        height: 30, // Standard keystone visible height
        depth: 15,
        name: `${ports}-Port Patch Panel`,
      };
    }

    // Special handling for Pi 5 case mount - use case dimensions
    if (device.mountType === 'pi5_case') {
      return {
        width: 93,   // PI5_CASE_FACE_W (85 + 2*(2+1))
        height: 64,  // PI5_CASE_FACE_H (56 + 2*(2+1))
        depth: 35,   // PI5_CASE_DEPTH
        name: 'Raspberry Pi 5 Case',
      };
    }

    return {
      width: deviceData.width,
      height: deviceData.height,
      depth: deviceData.depth,
      name: deviceData.name,
    };
  }

  // Fallback for unknown device
  return {
    width: 50,
    height: 30,
    depth: 50,
    name: device.deviceId,
  };
}

/**
 * Generate a default filename based on configuration
 */
export function generateFilename(config: RackConfig, extension: string, side?: 'left' | 'right'): string {
  const parts = [`rack_${config.rackU}u`];

  if (config.isSplit) {
    parts.push('split');
    if (side) {
      parts.push(side);
    }
  }

  const deviceCount = config.isSplit
    ? side === 'left'
      ? config.leftDevices.length
      : side === 'right'
        ? config.rightDevices.length
        : config.leftDevices.length + config.rightDevices.length
    : config.devices.length;

  if (deviceCount > 0) {
    parts.push(`${deviceCount}dev`);
  }

  return `${parts.join('_')}.${extension}`;
}

/**
 * Download SCAD code as a file
 */
export function downloadScadFile(config: RackConfig, filename?: string): void {
  const code = generateScadCode(config, false);
  const blob = new Blob([code], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = filename || generateFilename(config, 'scad');
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

/**
 * Export configuration as JSON
 */
export function exportConfigJson(config: RackConfig): string {
  return JSON.stringify(config, null, 2);
}

/**
 * Download configuration as JSON file
 */
export function downloadConfigJson(config: RackConfig, filename = 'rack_config.json'): void {
  const json = exportConfigJson(config);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

/**
 * Parse configuration from JSON
 */
export function parseConfigJson(json: string): RackConfig | null {
  try {
    const config = JSON.parse(json);
    // Basic validation
    if (typeof config.rackU === 'number' && Array.isArray(config.devices)) {
      return config as RackConfig;
    }
    return null;
  } catch {
    return null;
  }
}

/**
 * Download an ArrayBuffer as a file
 */
export function downloadArrayBuffer(data: ArrayBuffer, filename: string, mimeType: string): void {
  const blob = new Blob([data], { type: mimeType });
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

/**
 * Download STL data
 */
export function downloadStl(data: ArrayBuffer, config: RackConfig, side?: 'left' | 'right'): void {
  const filename = generateFilename(config, 'stl', side);
  downloadArrayBuffer(data, filename, 'application/sla');
}

/**
 * Generate SCAD code for a specific side of a split panel
 */
export function generateScadCodeForSide(config: RackConfig, side: 'left' | 'right'): string {
  const renderMode = side === 'left' ? 'left_print' : 'right_print';
  return generateScadCode({ ...config, renderMode }, false);
}

/**
 * Download both split sides as separate STL files in a ZIP
 */
export async function downloadSplitStlZip(
  leftStl: ArrayBuffer,
  rightStl: ArrayBuffer,
  config: RackConfig
): Promise<void> {
  const zip = new JSZip();

  // Generate filenames for each side
  const leftFilename = generateFilename(config, 'stl', 'left');
  const rightFilename = generateFilename(config, 'stl', 'right');

  // Add both STL files to the ZIP
  zip.file(leftFilename, leftStl);
  zip.file(rightFilename, rightStl);

  // Generate ZIP filename
  const zipFilename = `rack_${config.rackU}u_split_${config.leftDevices.length + config.rightDevices.length}dev.zip`;

  // Generate and download the ZIP
  const zipBlob = await zip.generateAsync({ type: 'blob' });
  const url = URL.createObjectURL(zipBlob);

  const a = document.createElement('a');
  a.href = url;
  a.download = zipFilename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
